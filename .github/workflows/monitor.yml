name: ä¸œæ¨ªInn ç›‘æ§ (æ‰‹æœ¯åˆ€å»å™ªç‰ˆ)

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  check_rooms:
    runs-on: ubuntu-latest
    steps:
      - name: æ‹‰å–ä»£ç 
        uses: actions/checkout@v3

      - name: è®¾ç½® Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: å®‰è£…ä¾èµ–
        run: pip install requests beautifulsoup4 resend

      - name: æ‰¹é‡è¿è¡Œç›‘æ§
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          USER_EMAIL: ${{ secrets.USER_EMAIL }}
        run: |
          python -c "
          import requests
          from bs4 import BeautifulSoup
          import os
          import resend
          import time
          from urllib.parse import urlparse, parse_qs
          import re
          import traceback

          # 1. åŸºç¡€é…ç½®
          resend.api_key = os.environ.get('RESEND_API_KEY')
          raw_email = os.environ.get('USER_EMAIL', '')
          user_email = raw_email.strip()

          headers = {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
              'Accept-Language': 'zh-CN,zh;q=0.9', 
          }

          try:
              with open('urls.txt', 'r') as f:
                  urls = [line.strip() for line in f if line.strip()]
          except FileNotFoundError:
              print('âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ° urls.txt')
              exit(1)

          print(f'ğŸ“‹ å¯åŠ¨ç›‘æ§: {len(urls)} ä¸ªä»»åŠ¡ (é€»è¾‘: å»é™¤é¡µçœ‰é¡µè„šå™ªéŸ³ + ä¿®å¤é‚®ä»¶æŠ¥é”™)\n')
          
          found_list = []

          for i, url in enumerate(urls):
              # è§£æ URL å‚æ•°
              try:
                  parsed = urlparse(url)
                  params = parse_qs(parsed.query)
                  hotel_id = params.get('hotel', ['æœªçŸ¥'])[0]
                  checkin_date = params.get('start', ['æœªçŸ¥'])[0]
                  
                  max_limit = 999999
                  if 'max' in params:
                      try: max_limit = int(params['max'][0])
                      except: pass
                  
                  min_limit = 5000 
                  if 'min' in params:
                      try: min_limit = int(params['min'][0])
                      except: pass
                      
              except:
                  hotel_id, checkin_date = 'æœªçŸ¥', 'æœªçŸ¥'
                  max_limit = 999999
                  min_limit = 5000

              limit_info = f' (é¢„ç®—: {min_limit}~{max_limit})'
              print(f'[{i+1}/{len(urls)}] ğŸ¨ {hotel_id} | ğŸ“… {checkin_date}{limit_info}')
              
              try:
                  resp = requests.get(url, headers=headers, timeout=30)
                  
                  # === ğŸ”¥ å…³é”®æ‰‹æœ¯ï¼šå»é™¤é¡µçœ‰é¡µè„šå™ªéŸ³ ğŸ”¥ ===
                  soup = BeautifulSoup(resp.text, 'html.parser')
                  
                  # 1. ç§»é™¤ script, style (é˜²å¹²æ‰°)
                  for script in soup(['script', 'style', 'noscript', 'iframe']):
                      script.decompose()
                      
                  # 2. ç§»é™¤ Header å’Œ Footer (7600 å’Œ 8000 é€šå¸¸åœ¨è¿™é‡Œ)
                  # è¿™ä¸€æ­¥ä¼šåˆ æ‰ç½‘é¡µé¡¶éƒ¨å¯¼èˆªå’Œåº•éƒ¨ç‰ˆæƒåŒº
                  for trash in soup(['header', 'footer', 'nav']):
                      trash.decompose()

                  # 3. é’ˆå¯¹æ€§ç§»é™¤å¸¸è§çš„åº•éƒ¨é“¾æ¥åŒº (é€šå¸¸åŒ…å«å¾ˆå¤šæ— å…³æ•°å­—)
                  # å°è¯•ç§»é™¤ class åŒ…å« footer æˆ– header çš„ div
                  for div in soup.find_all('div', class_=re.compile(r'footer|header|banner|advert')):
                      div.decompose()

                  # åªè·å–æ¸…æ´—åçš„çº¯æ–‡æœ¬
                  clean_text = soup.get_text()
                  
                  # === ä»·æ ¼æå– ===
                  valid_prices = []
                  # æ­£åˆ™åŒ¹é…
                  raw_matches = re.findall(r'Â¥\s*([0-9,]+)', clean_text)
                  
                  debug_prices = []
                  for p in raw_matches:
                      try:
                          val = int(p.replace(',', ''))
                          debug_prices.append(val)
                          if val != 10000 and val >= min_limit: 
                              valid_prices.append(val)
                      except: pass
                  
                  # æ‰“å° debug ä¿¡æ¯ (çœ‹çœ‹å™ªéŸ³æ˜¯ä¸æ˜¯å°‘äº†)
                  # print(f'      ğŸ” å‡€åŒ–åæŠ“å–: {debug_prices}') 
                  
                  real_min_price = min(valid_prices) if valid_prices else 999999
                  
                  # === åˆ¤å®šæ˜¯å¦æœ‰æˆ¿ ===
                  # å…³é”®å­—æ£€æŸ¥
                  has_stock = re.search(r'å‰©\s*\d+\s*é—´', clean_text)
                  has_btn = 'é¢„è®¢' in clean_text or 'reserve' in clean_text.lower()
                  
                  is_available = False
                  status_msg = 'ğŸ˜´ æš‚æ— ç©ºæˆ¿'

                  if has_stock or has_btn or (valid_prices and 'æ²¡æœ‰ç©ºæˆ¿' not in clean_text):
                      if real_min_price <= max_limit:
                          is_available = True
                          price_show = f'Â¥{real_min_price}' if real_min_price < 999999 else 'ä»·æ ¼æœªçŸ¥'
                          status_msg = f'ğŸ‰ å‘ç°ç©ºæˆ¿ä¸”ä»·æ ¼åˆé€‚! (æœ€ä½ {price_show})'
                      else:
                          status_msg = f'ğŸ’¸ æœ‰æˆ¿ä½†å¤ªè´µ (æœ€ä½ Â¥{real_min_price} > é¢„ç®— {max_limit})'
                  
                  print(f'      {status_msg}')

                  if is_available:
                      found_list.append({
                          'id': hotel_id,
                          'date': checkin_date,
                          'url': url,
                          'price': real_min_price if real_min_price < 999999 else 0
                      })
                  
                  time.sleep(2)

              except Exception as e:
                  print(f'      âŒ å‡ºé”™: {e}')
              print('-'*40)

          # å‘é€é‚®ä»¶ (å·²ä¿®å¤å˜é‡åæŠ¥é”™)
          if found_list:
              print(f'\nğŸ“§ å‘ç° {len(found_list)} ä¸ªç¬¦åˆæ¡ä»¶çš„ç›®æ ‡...')
              
              if not user_email or '@' not in user_email:
                  print('âŒ USER_EMAIL æœªé…ç½®')
              elif not resend.api_key:
                  print('âŒ RESEND_API_KEY æœªé…ç½®')
              else:
                  try:
                      first = found_list[0]
                      # âœ… ä¿®å¤ç‚¹ï¼šæ­£ç¡®ä½¿ç”¨å­—å…¸è®¿é—®å˜é‡
                      p_val = first['price']
                      checkin_str = first['date'] 
                      
                      p_title = f'Â¥{p_val}' if p_val > 0 else 'æœ‰æˆ¿'
                      subject_txt = f'ã€æœ‰æˆ¿ã€‘{checkin_str} {p_title} (ç¬¦åˆé¢„ç®—)'
                      
                      email_body = '<h3>ğŸ‰ å‘ç°ç¬¦åˆé¢„ç®—çš„ç©ºæˆ¿ï¼š</h3><ul>'
                      for item in found_list:
                          i_price = item["price"]
                          p_str = f'Â¥{i_price}' if i_price > 0 else 'æœ‰ç©ºæˆ¿'
                          email_body += f'<li><strong>{item["date"]} (åº—å·{item["id"]})</strong><br>ä»·æ ¼: <span style="color:red">{p_str}</span><br><a href=\"{item["url"]}\">ğŸ‘‰ ç‚¹å‡»ç«‹å³é¢„è®¢</a></li>'
                      email_body += '</ul>'
                  
                      resend.Emails.send({
                        'from': 'onboarding@resend.dev',
                        'to': user_email,
                        'subject': subject_txt,
                        'html': email_body
                      })
                      print('âœ… é‚®ä»¶å‘é€æˆåŠŸï¼')
                  except Exception as e:
                      print(f'âŒ é‚®ä»¶å‘é€å¤±è´¥: {e}')
                      traceback.print_exc()
          else:
              print('\nğŸ ç›‘æ§ç»“æŸï¼Œæ— ç¬¦åˆæ¡ä»¶æˆ¿æºã€‚')
          "
